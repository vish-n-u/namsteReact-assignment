Q1) What is Micro-service?
Microservice is an architectural implementation where independent features of an application
is created as its own separate application, these make testing , debugging and also
creation of an app easily manageable, for example when you signup to an application,
you usually recieve an otp to your email or your phn number , this otp creation ,
sending it to you and validating can be made as a separate service. The user generally doesnot
know that these are different services. 

Microservices - also known as the microservice architecture - is an architectural 
style that structures an application as a collection of services that are

Independently deployable
Loosely coupled
Organized around business capabilities
Owned by a small team
Highly maintainable and testable.
Talk to other services over well defined APIs.
The microservice architecture enables the rapid, frequent and reliable delivery of 
large, complex applications. It also enables an organization to evolve its technology 
stack.


Q2) What are Monolith Application?

An application every unique feature is built inside the same app is known as a Monolith App.
Monolith is an outdated form architectural style. 
As Apps get bigger over time a monolith application becomes harder and harder to maintain.
Debugging/ Testing  becomes incredibly tough.
Multiple tech stack for individual feature is not possible
Reading and Maintaining becomes a hedache.

benefits:- 
Starting a Monolith project is easy

With monolithic architectures, all processes are tightly coupled and run as a single
service. This means that if one process of the application experiences a spike in demand, 
the entire architecture must be scaled. Adding or improving a monolithic application’s 
features becomes more complex as the code base grows. This complexity limits experimentation
and makes it difficult to implement new ideas. Monolithic architectures add risk for 
application availability because many dependent and tightly coupled processes increase 
the impact of a single process failure.

Q3) Why do we need a UseEffect Hook?
The useEffect hook renders the component again after the initial render, which makes it
very useful in most scenarios where it takes time to display data in the ui, because we
can make an initial loading or a shimmer ui which will be shown in the ui immediately 
during the initial render after which during the re-render the actual data is displayed.
Arguments can be provided which controls when th re-render should happen.

Q4) What is optional chaining?
Optional chaining is a javascript method, where when trying to get nested data you use
"?" between each nested obj for eg
obj = {
    abc:{
        key :[1,2,3,{
            ls:{
                a:[1,2,{
                    a:1,b:2
                },3]
            }
        }]
    }
}

so if you want to get "b"'s value in rs
then you will write 
let data(not necessary) = obj?.abc?.key[3]?.ls?.a[2]?.b

this would return the correct data,
but lets assume you wrote (notice the index in key is wrong)
let data(not necessary) = obj?.abc?.key[2]?.ls?.a[2]?.b,
instead of throwing an error and stopping the whole app it would just return undefined


The optional chaining (?.) operator accesses an object's property or calls a function. 
If the object accessed or function called using this operator is undefined or null, 
the expression short circuits and evaluates to undefined instead of throwing an error.

Q3) What is ShimmerUI ?
During initial render when imges or other data has not yet been fetched we can show something
known as a ShimmerUI instead of the load sign, Shimmer UI is sort of like just the border
of each content that is going to show up in UI.

A shimmer screen is a version of the UI that doesn’t contain actual content. Instead, 
it mimics the page’s layout by showing its elements in a shape similar to the actual 
content as it is loading and becoming available (i.e. when network latency allows).

A shimmer screen is essentially a wireframe of the page, with placeholder boxes for text 
and images.

Q4) What is difference between js expression and js statement?
A js expression is something that evaluates to a value
A js statement can evaluate to a value but does not need to , so every js expression is
also a statement but the opposite isnt true


Want to know whether a chunk of JS is an expression or a statement? Try to log it out!

console.log(/* Some chunk of JS here */);
If it runs, the code is an expression. If you get an error, it's a statement 
(or, possibly, invalid JS).

Here is an expression: 1 + 2 + 3.

What happens if we create a JS file that includes only this expression? Let's imagine we 
save the following content as test.js:
1 + 2 + 3
How many statements does this file have? Zero or one?

Here's the deal: expressions can't exist on their own. They're always part of a statement. 
And so in this case, we have a statement that looks like this:
/* expression slot */
The statement is essentially empty aside from its expression slot. Our expression 1 + 2 + 3 fills this slot, and our statement is complete.

In other words, all of the following lines are valid statements:

JS
// Statement 1:
let hi = /* expression slot */;
// Statement 2:
return /* expression slot */;
// Statement 3:
if (/* expression slot */) { }
// Statement 4:
/* expression slot */


Here is an expression: 1 + 2 + 3.

What happens if we create a JS file that includes only this expression? Let's imagine we 
save the following content as test.js:

JS
1 + 2 + 3
How many statements does this file have? Zero or one

Here's the deal: expressions can't exist on their own. They're always part of a statement.
 And so in this case, we have a statement that looks like this:

/* expression slot */

The statement is essentially empty aside from its expression slot. Our expression 1 + 2 + 3
fills this slot, and our statement is complete.

In other words, all of the following lines are valid statements:
/ Statement 1:
let hi = /* expression slot */;
// Statement 2:
return /* expression slot */;
// Statement 3:
if (/* expression slot */) { }
// Statement 4:
/* expression slot */

Often, tutorials will falsely state that expressions are statements, but this isn't 
quite right. Expressions and statements are distinct things. But it's possible for a 
statement to wrap around an expression without providing any additional characters. 
Think of it like wrapping a sandwich in clear shrink wrap.

Statements typically end in a semi-colon, which marks the end of the statement. The 
semi-colon isn't necessary for certain statements, like if statements, while loops, and 
function declarations.



Q5 What is conditional rendering? Give example
conditional rendering as the name suggests is rendering based on a given condition,
it is usually written as
return (condition)? (if true) abc : (if false) xyz
we use ternary operation instead of if else because ternary operation is an expression
while if else are statement

Q6) What are CORS?
CORS:- Cross Origin Resource Sharing is a safety mecanism by the browser where it
does not allow data from other origins. Origins in this case can mean a different  website,
the same app running in a different port number.
CORS also relies on a mechanism by which browsers make a "preflight" request to the server 
hosting the cross-origin resource, in order to check that the server will permit the actual 
request. In that preflight, the browser sends headers that indicate the HTTP method and 
headers that will be used in the actual request.

Q7) What is async await?
Javascript is an asynchronous, single threaded language which means that  any operation that 
is not actually executed by js (fetch operations) or something like setTimeout , is actually
put aside and executed after the non js part is completed.
for eg
let data = fetch("abc.com/img/...")
But what if you want to console "data" , or you want to use that data, how would you know 
when the fetch operation is complete so that you dont call the data before it has been 
fetched and recieve an error...
so for those reason a new object comes into play, something known as Promise
Promise is a placeholder for value which be filled in the future...
Promises have 3 states
pending(The operation is yet to be completed)
fulfilled(The operation is completed amd it returned a value)
rejected(The operation is not completed and some err has occured)

so now whenever you console "data" it wont throw an error instead it would print the state
of the Promise

But this still does nit help us with using  the "data" itself,
so previously whenever you wanted to use the promise after it was out of its pending state
We used callback functions known as .then and .catch
so the code would look something like :- 

let data = fetch("abc.com/img/...")
data.then((result)=>{
    // do something
})

data.catch((err)=>{
    // do something
})

You might be wondering why we have 2 callback functions that is because,
Realistically there is no foolproof way to make an async operation always successful,
primarily because it depends on external factor, so it makes sense to be prepared for both
the scenarios always.
Hence we have  .then() when the promise is fullfiled
and .catch when there promise is rejected

But this way of operating on promise also has its flaw
What if the promise returns a promise? and what if that in turn returns promise,
nested promises can cause the code to get messy (imagine the lines of .then and .catch),

so we now have async and await which is just a syntatic sugar on .then and catch
it makes the code much more readable and it looks like an async operation is working
in a synchronous manner
it looks like

async function late(){
    let data = await fetch("abc.com/img/...")

}

Q) Why use json.data()
Response.json()
The json() method of the Response interface takes a Response stream and reads it to 
completion. It returns a promise which resolves with the result of parsing the body text 
as JSON.

Note that despite the method being named json(), the result is not JSON but is instead the 
result of taking JSON as input and parsing it to produce a JavaScript object.